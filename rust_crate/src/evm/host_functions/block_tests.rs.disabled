// Copyright (C) 2021-2025 the DTVM authors. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//! Unit tests for block information host functions

#[cfg(test)]
mod tests {
    use super::*;
    use crate::evm::{MockContext, BlockInfo};
    use crate::evm::host_functions::block::*;
    
    // Mock ZenInstance for testing
    struct MockZenInstance {
        context: MockContext,
        memory: Vec<u8>,
    }
    
    impl MockZenInstance {
        fn new(context: MockContext) -> Self {
            Self {
                context,
                memory: vec![0u8; 4096], // 4KB mock memory
            }
        }
        
        fn validate_wasm_addr(&self, offset: u32, length: u32) -> bool {
            (offset as usize + length as usize) <= self.memory.len()
        }
        
        unsafe fn get_host_memory(&self, offset: u32) -> *const u8 {
            self.memory.as_ptr().add(offset as usize)
        }
        
        fn read_from_memory(&self, offset: u32, length: u32) -> Vec<u8> {
            let start = offset as usize;
            let end = start + length as usize;
            if end <= self.memory.len() {
                self.memory[start..end].to_vec()
            } else {
                vec![]
            }
        }
    }
    
    impl AsRef<MockContext> for MockZenInstance {
        fn as_ref(&self) -> &MockContext {
            &self.context
        }
    }
    
    #[test]
    fn test_get_block_number_default() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        let block_number = get_block_number(&instance);
        assert_eq!(block_number, 12345); // Default value
    }
    
    #[test]
    fn test_get_block_number_custom() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        context.set_block_number(999999);
        let instance = MockZenInstance::new(context);
        
        let block_number = get_block_number(&instance);
        assert_eq!(block_number, 999999);
    }
    
    #[test]
    fn test_get_block_timestamp_default() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        let timestamp = get_block_timestamp(&instance);
        assert_eq!(timestamp, 1234567890); // Default value
    }
    
    #[test]
    fn test_get_block_timestamp_custom() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        context.set_block_timestamp(1700000000);
        let instance = MockZenInstance::new(context);
        
        let timestamp = get_block_timestamp(&instance);
        assert_eq!(timestamp, 1700000000);
    }
    
    #[test]
    fn test_get_block_gas_limit_default() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        let gas_limit = get_block_gas_limit(&instance);
        assert_eq!(gas_limit, 1000000); // Default value
    }
    
    #[test]
    fn test_get_block_gas_limit_custom() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        let custom_block = BlockInfo::new(
            12345,
            1234567890,
            30000000, // Custom gas limit
            [0x11; 20],
            [0x22; 32],
            [0x33; 32],
            [0x44; 32],
        );
        context.set_block_info(custom_block);
        let instance = MockZenInstance::new(context);
        
        let gas_limit = get_block_gas_limit(&instance);
        assert_eq!(gas_limit, 30000000);
    }
    
    #[test]
    fn test_get_block_coinbase_default() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        let result = get_block_coinbase(&instance, result_offset as i32);
        assert!(result.is_ok());
        
        let coinbase = instance.read_from_memory(result_offset, 20);
        assert_eq!(coinbase.len(), 20);
        assert_eq!(coinbase[0], 0x02); // Default coinbase prefix
    }
    
    #[test]
    fn test_get_block_coinbase_custom() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        let custom_coinbase = [0x55; 20];
        let custom_block = BlockInfo::new(
            12345,
            1234567890,
            1000000,
            custom_coinbase,
            [0x22; 32],
            [0x33; 32],
            [0x44; 32],
        );
        context.set_block_info(custom_block);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        let result = get_block_coinbase(&instance, result_offset as i32);
        assert!(result.is_ok());
        
        let coinbase = instance.read_from_memory(result_offset, 20);
        assert_eq!(coinbase, custom_coinbase.to_vec());
    }
    
    #[test]
    fn test_get_block_coinbase_invalid_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative offset
        let result = get_block_coinbase(&instance, -1);
        assert!(result.is_err());
        
        // Test out-of-bounds offset
        let result = get_block_coinbase(&instance, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_get_block_prev_randao_default() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        let result = get_block_prev_randao(&instance, result_offset as i32);
        assert!(result.is_ok());
        
        let prev_randao = instance.read_from_memory(result_offset, 32);
        assert_eq!(prev_randao.len(), 32);
        assert_eq!(prev_randao[0], 0x01); // Default prev_randao prefix
    }
    
    #[test]
    fn test_get_block_prev_randao_custom() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        let custom_prev_randao = [0x77; 32];
        let custom_block = BlockInfo::new(
            12345,
            1234567890,
            1000000,
            [0x11; 20],
            custom_prev_randao,
            [0x33; 32],
            [0x44; 32],
        );
        context.set_block_info(custom_block);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        let result = get_block_prev_randao(&instance, result_offset as i32);
        assert!(result.is_ok());
        
        let prev_randao = instance.read_from_memory(result_offset, 32);
        assert_eq!(prev_randao, custom_prev_randao.to_vec());
    }
    
    #[test]
    fn test_get_block_prev_randao_invalid_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative offset
        let result = get_block_prev_randao(&instance, -1);
        assert!(result.is_err());
        
        // Test out-of-bounds offset
        let result = get_block_prev_randao(&instance, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_get_block_hash_valid_block() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        context.set_block_number(1000);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        
        // Test getting hash for previous block
        let result = get_block_hash(&instance, 999, result_offset as i32);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1); // Success
        
        let block_hash = instance.read_from_memory(result_offset, 32);
        assert_eq!(block_hash.len(), 32);
        assert_eq!(block_hash[0], 0x06); // Mock block hash prefix
        
        // Verify block number is encoded in hash
        let block_bytes = (999u64).to_be_bytes();
        assert_eq!(&block_hash[1..9], &block_bytes);
    }
    
    #[test]
    fn test_get_block_hash_invalid_block() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        context.set_block_number(1000);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset = 0u32;
        
        // Test getting hash for future block
        let result = get_block_hash(&instance, 1001, result_offset as i32);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0); // Failure
        
        let block_hash = instance.read_from_memory(result_offset, 32);
        assert_eq!(block_hash, vec![0u8; 32]); // Zero hash
        
        // Test getting hash for negative block
        let result = get_block_hash(&instance, -1, result_offset as i32);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0); // Failure
        
        let block_hash = instance.read_from_memory(result_offset, 32);
        assert_eq!(block_hash, vec![0u8; 32]); // Zero hash
        
        // Test getting hash for current block
        let result = get_block_hash(&instance, 1000, result_offset as i32);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0); // Failure (can't get current block hash)
    }
    
    #[test]
    fn test_get_block_hash_invalid_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative offset
        let result = get_block_hash(&instance, 100, -1);
        assert!(result.is_err());
        
        // Test out-of-bounds offset
        let result = get_block_hash(&instance, 100, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_block_info_consistency() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        
        // Set custom block info
        let custom_block = BlockInfo::new(
            555555,
            1600000000,
            25000000,
            [0xaa; 20],
            [0xbb; 32],
            [0xcc; 32],
            [0xdd; 32],
        );
        context.set_block_info(custom_block.clone());
        let mut instance = MockZenInstance::new(context);
        
        // Test all block info functions return consistent values
        assert_eq!(get_block_number(&instance), 555555);
        assert_eq!(get_block_timestamp(&instance), 1600000000);
        assert_eq!(get_block_gas_limit(&instance), 25000000);
        
        // Test coinbase
        let coinbase_offset = 0u32;
        let result = get_block_coinbase(&instance, coinbase_offset as i32);
        assert!(result.is_ok());
        let coinbase = instance.read_from_memory(coinbase_offset, 20);
        assert_eq!(coinbase, custom_block.coinbase.to_vec());
        
        // Test prev_randao
        let randao_offset = 32u32;
        let result = get_block_prev_randao(&instance, randao_offset as i32);
        assert!(result.is_ok());
        let prev_randao = instance.read_from_memory(randao_offset, 32);
        assert_eq!(prev_randao, custom_block.prev_randao.to_vec());
    }
    
    #[test]
    fn test_block_hash_different_blocks() {
        let mut context = MockContext::new(vec![0x60, 0x80]);
        context.set_block_number(1000);
        let mut instance = MockZenInstance::new(context);
        
        let result_offset1 = 0u32;
        let result_offset2 = 32u32;
        
        // Get hashes for different blocks
        let result1 = get_block_hash(&instance, 500, result_offset1 as i32);
        assert!(result1.is_ok());
        assert_eq!(result1.unwrap(), 1);
        
        let result2 = get_block_hash(&instance, 600, result_offset2 as i32);
        assert!(result2.is_ok());
        assert_eq!(result2.unwrap(), 1);
        
        let hash1 = instance.read_from_memory(result_offset1, 32);
        let hash2 = instance.read_from_memory(result_offset2, 32);
        
        // Hashes should be different
        assert_ne!(hash1, hash2);
        
        // But both should have the mock prefix
        assert_eq!(hash1[0], 0x06);
        assert_eq!(hash2[0], 0x06);
        
        // And contain their respective block numbers
        let block1_bytes = (500u64).to_be_bytes();
        let block2_bytes = (600u64).to_be_bytes();
        assert_eq!(&hash1[1..9], &block1_bytes);
        assert_eq!(&hash2[1..9], &block2_bytes);
    }
}