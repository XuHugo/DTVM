// Copyright (C) 2021-2025 the DTVM authors. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//! Unit tests for cryptographic host functions

#[cfg(test)]
mod tests {
    use super::*;
    use crate::evm::MockContext;
    use crate::evm::host_functions::crypto::*;
    
    // Mock ZenInstance for testing
    struct MockZenInstance {
        context: MockContext,
        memory: Vec<u8>,
    }
    
    impl MockZenInstance {
        fn new(context: MockContext) -> Self {
            Self {
                context,
                memory: vec![0u8; 4096], // 4KB mock memory
            }
        }
        
        fn validate_wasm_addr(&self, offset: u32, length: u32) -> bool {
            (offset as usize + length as usize) <= self.memory.len()
        }
        
        unsafe fn get_host_memory(&self, offset: u32) -> *const u8 {
            self.memory.as_ptr().add(offset as usize)
        }
        
        fn write_to_memory(&mut self, offset: u32, data: &[u8]) {
            let start = offset as usize;
            let end = start + data.len();
            if end <= self.memory.len() {
                self.memory[start..end].copy_from_slice(data);
            }
        }
        
        fn read_from_memory(&self, offset: u32, length: u32) -> Vec<u8> {
            let start = offset as usize;
            let end = start + length as usize;
            if end <= self.memory.len() {
                self.memory[start..end].to_vec()
            } else {
                vec![]
            }
        }
    }
    
    impl AsRef<MockContext> for MockZenInstance {
        fn as_ref(&self) -> &MockContext {
            &self.context
        }
    }
    
    #[test]
    fn test_sha256_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data
        let input_data = b"Hello, World!";
        let input_offset = 0u32;
        let result_offset = 64u32;
        
        // Write input data to memory
        instance.write_to_memory(input_offset, input_data);
        
        // Call sha256
        let result = sha256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        // Read the result
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result.len(), 32);
        
        // Verify it's a mock SHA256 hash (starts with 0x12)
        assert_eq!(hash_result[0], 0x12);
        
        // Verify length is encoded in the hash
        let length_bytes = (input_data.len() as u32).to_be_bytes();
        assert_eq!(&hash_result[1..5], &length_bytes);
        
        // Verify first few bytes of input are in the hash
        let copy_len = std::cmp::min(input_data.len(), 8);
        assert_eq!(&hash_result[8..8 + copy_len], &input_data[..copy_len]);
    }
    
    #[test]
    fn test_keccak256_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data
        let input_data = b"Ethereum";
        let input_offset = 0u32;
        let result_offset = 64u32;
        
        // Write input data to memory
        instance.write_to_memory(input_offset, input_data);
        
        // Call keccak256
        let result = keccak256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        // Read the result
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result.len(), 32);
        
        // Verify it's a mock Keccak256 hash (starts with 0x23)
        assert_eq!(hash_result[0], 0x23);
        
        // Verify length is encoded in the hash (different position than SHA256)
        let length_bytes = (input_data.len() as u32).to_be_bytes();
        assert_eq!(&hash_result[2..6], &length_bytes);
        
        // Verify last few bytes of input are in the hash (different from SHA256)
        let copy_len = std::cmp::min(input_data.len(), 6);
        let start_idx = input_data.len() - copy_len;
        assert_eq!(&hash_result[10..10 + copy_len], &input_data[start_idx..]);
        
        // Verify length modulo is in the last byte
        assert_eq!(hash_result[31], (input_data.len() % 256) as u8);
    }
    
    #[test]
    fn test_sha256_vs_keccak256_different() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Same input data
        let input_data = b"test data";
        let input_offset = 0u32;
        let sha256_result_offset = 64u32;
        let keccak256_result_offset = 96u32;
        
        // Write input data to memory
        instance.write_to_memory(input_offset, input_data);
        
        // Call both hash functions
        let sha256_result = sha256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            sha256_result_offset as i32,
        );
        assert!(sha256_result.is_ok());
        
        let keccak256_result = keccak256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            keccak256_result_offset as i32,
        );
        assert!(keccak256_result.is_ok());
        
        // Read both results
        let sha256_hash = instance.read_from_memory(sha256_result_offset, 32);
        let keccak256_hash = instance.read_from_memory(keccak256_result_offset, 32);
        
        // Verify they are different
        assert_ne!(sha256_hash, keccak256_hash);
        
        // Verify different prefixes
        assert_eq!(sha256_hash[0], 0x12);
        assert_eq!(keccak256_hash[0], 0x23);
    }
    
    #[test]
    fn test_hash_empty_input() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        let input_offset = 0u32;
        let result_offset = 32u32;
        
        // Test SHA256 with empty input
        let result = sha256(&instance, input_offset as i32, 0, result_offset as i32);
        assert!(result.is_ok());
        
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result.len(), 32);
        assert_eq!(hash_result[0], 0x12); // SHA256 prefix
        
        // Length should be 0
        assert_eq!(&hash_result[1..5], &[0, 0, 0, 0]);
        
        // Test Keccak256 with empty input
        let result = keccak256(&instance, input_offset as i32, 0, result_offset as i32);
        assert!(result.is_ok());
        
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result.len(), 32);
        assert_eq!(hash_result[0], 0x23); // Keccak256 prefix
        
        // Length should be 0
        assert_eq!(&hash_result[2..6], &[0, 0, 0, 0]);
        assert_eq!(hash_result[31], 0); // 0 % 256 = 0
    }
    
    #[test]
    fn test_hash_large_input() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Large input data (1KB)
        let input_data = vec![0x42; 1024];
        let input_offset = 0u32;
        let result_offset = 1024u32;
        
        // Write input data to memory
        instance.write_to_memory(input_offset, &input_data);
        
        // Test SHA256
        let result = sha256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result[0], 0x12);
        
        // Verify length encoding
        let length_bytes = (input_data.len() as u32).to_be_bytes();
        assert_eq!(&hash_result[1..5], &length_bytes);
        
        // Test Keccak256
        let result = keccak256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        let hash_result = instance.read_from_memory(result_offset, 32);
        assert_eq!(hash_result[0], 0x23);
        assert_eq!(hash_result[31], (input_data.len() % 256) as u8);
    }
    
    #[test]
    fn test_hash_invalid_input_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative input offset
        let result = sha256(&instance, -1, 10, 32);
        assert!(result.is_err());
        
        let result = keccak256(&instance, -1, 10, 32);
        assert!(result.is_err());
        
        // Test out-of-bounds input offset
        let result = sha256(&instance, 4096, 10, 32);
        assert!(result.is_err());
        
        let result = keccak256(&instance, 4096, 10, 32);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_hash_invalid_input_length() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative input length
        let result = sha256(&instance, 0, -1, 32);
        assert!(result.is_err());
        
        let result = keccak256(&instance, 0, -1, 32);
        assert!(result.is_err());
        
        // Test input length that would exceed memory bounds
        let result = sha256(&instance, 0, 5000, 32);
        assert!(result.is_err());
        
        let result = keccak256(&instance, 0, 5000, 32);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_hash_invalid_result_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative result offset
        let result = sha256(&instance, 0, 10, -1);
        assert!(result.is_err());
        
        let result = keccak256(&instance, 0, 10, -1);
        assert!(result.is_err());
        
        // Test out-of-bounds result offset
        let result = sha256(&instance, 0, 10, 4096);
        assert!(result.is_err());
        
        let result = keccak256(&instance, 0, 10, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_hash_deterministic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        let input_data = b"deterministic test";
        let input_offset = 0u32;
        let result1_offset = 64u32;
        let result2_offset = 96u32;
        
        // Write input data to memory
        instance.write_to_memory(input_offset, input_data);
        
        // Call SHA256 twice with same input
        let result1 = sha256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result1_offset as i32,
        );
        assert!(result1.is_ok());
        
        let result2 = sha256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result2_offset as i32,
        );
        assert!(result2.is_ok());
        
        // Results should be identical
        let hash1 = instance.read_from_memory(result1_offset, 32);
        let hash2 = instance.read_from_memory(result2_offset, 32);
        assert_eq!(hash1, hash2);
        
        // Same test for Keccak256
        let result1 = keccak256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result1_offset as i32,
        );
        assert!(result1.is_ok());
        
        let result2 = keccak256(
            &instance,
            input_offset as i32,
            input_data.len() as i32,
            result2_offset as i32,
        );
        assert!(result2.is_ok());
        
        let hash1 = instance.read_from_memory(result1_offset, 32);
        let hash2 = instance.read_from_memory(result2_offset, 32);
        assert_eq!(hash1, hash2);
    }
}