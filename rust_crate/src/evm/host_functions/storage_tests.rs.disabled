// Copyright (C) 2021-2025 the DTVM authors. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//! Unit tests for storage host functions

#[cfg(test)]
mod tests {
    use super::*;
    use crate::evm::{MockContext, MemoryAccessor};
    use crate::evm::error::HostFunctionError;
    use crate::core::instance::ZenInstance;
    use crate::evm::host_functions::storage::*;
    
    // Mock ZenInstance for testing
    struct MockZenInstance {
        context: MockContext,
        memory: Vec<u8>,
    }
    
    impl MockZenInstance {
        fn new(context: MockContext) -> Self {
            Self {
                context,
                memory: vec![0u8; 4096], // 4KB mock memory
            }
        }
        
        fn validate_wasm_addr(&self, offset: u32, length: u32) -> bool {
            (offset as usize + length as usize) <= self.memory.len()
        }
        
        unsafe fn get_host_memory(&self, offset: u32) -> *const u8 {
            self.memory.as_ptr().add(offset as usize)
        }
    }
    
    impl AsRef<MockContext> for MockZenInstance {
        fn as_ref(&self) -> &MockContext {
            &self.context
        }
    }
    
    #[test]
    fn test_storage_store_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data in memory
        let key_offset = 0u32;
        let value_offset = 32u32;
        
        // Write test key to memory (32 bytes)
        let test_key = [0x12; 32];
        unsafe {
            std::ptr::copy_nonoverlapping(
                test_key.as_ptr(),
                instance.memory.as_mut_ptr().add(key_offset as usize),
                32
            );
        }
        
        // Write test value to memory (32 bytes)
        let test_value = [0x34; 32];
        unsafe {
            std::ptr::copy_nonoverlapping(
                test_value.as_ptr(),
                instance.memory.as_mut_ptr().add(value_offset as usize),
                32
            );
        }
        
        // Call storage_store
        let result = storage_store(&instance, key_offset as i32, value_offset as i32);
        assert!(result.is_ok());
        
        // Verify the value was stored
        let key_hex = format!("0x{}", hex::encode(&test_key));
        let stored_value = instance.context.get_storage(&key_hex);
        assert_eq!(stored_value, test_value.to_vec());
    }
    
    #[test]
    fn test_storage_load_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Pre-populate storage
        let test_key = [0x56; 32];
        let test_value = [0x78; 32];
        let key_hex = format!("0x{}", hex::encode(&test_key));
        instance.context.set_storage_bytes32(&key_hex, test_value);
        
        // Prepare memory
        let key_offset = 0u32;
        let result_offset = 32u32;
        
        // Write test key to memory
        unsafe {
            std::ptr::copy_nonoverlapping(
                test_key.as_ptr(),
                instance.memory.as_mut_ptr().add(key_offset as usize),
                32
            );
        }
        
        // Call storage_load
        let result = storage_load(&instance, key_offset as i32, result_offset as i32);
        assert!(result.is_ok());
        
        // Verify the value was loaded to memory
        let loaded_value = &instance.memory[result_offset as usize..(result_offset + 32) as usize];
        assert_eq!(loaded_value, &test_value);
    }
    
    #[test]
    fn test_storage_store_invalid_key_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test with negative key offset
        let result = storage_store(&instance, -1, 32);
        assert!(result.is_err());
        
        // Test with out-of-bounds key offset
        let result = storage_store(&instance, 4096, 32);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_storage_store_invalid_value_offset() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test with negative value offset
        let result = storage_store(&instance, 0, -1);
        assert!(result.is_err());
        
        // Test with out-of-bounds value offset
        let result = storage_store(&instance, 0, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_storage_load_nonexistent_key() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare memory with a key that doesn't exist in storage
        let key_offset = 0u32;
        let result_offset = 32u32;
        
        let nonexistent_key = [0x99; 32];
        unsafe {
            std::ptr::copy_nonoverlapping(
                nonexistent_key.as_ptr(),
                instance.memory.as_mut_ptr().add(key_offset as usize),
                32
            );
        }
        
        // Call storage_load
        let result = storage_load(&instance, key_offset as i32, result_offset as i32);
        assert!(result.is_ok());
        
        // Should return all zeros for nonexistent key
        let loaded_value = &instance.memory[result_offset as usize..(result_offset + 32) as usize];
        assert_eq!(loaded_value, &[0u8; 32]);
    }
    
    #[test]
    fn test_storage_load_invalid_offsets() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test with negative key offset
        let result = storage_load(&instance, -1, 32);
        assert!(result.is_err());
        
        // Test with negative result offset
        let result = storage_load(&instance, 0, -1);
        assert!(result.is_err());
        
        // Test with out-of-bounds offsets
        let result = storage_load(&instance, 4096, 32);
        assert!(result.is_err());
        
        let result = storage_load(&instance, 0, 4096);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_storage_round_trip() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Test multiple key-value pairs
        let test_cases = vec![
            ([0x11; 32], [0xaa; 32]),
            ([0x22; 32], [0xbb; 32]),
            ([0x33; 32], [0xcc; 32]),
        ];
        
        for (key, value) in &test_cases {
            // Store the value
            let key_offset = 0u32;
            let value_offset = 32u32;
            
            unsafe {
                std::ptr::copy_nonoverlapping(
                    key.as_ptr(),
                    instance.memory.as_mut_ptr().add(key_offset as usize),
                    32
                );
                std::ptr::copy_nonoverlapping(
                    value.as_ptr(),
                    instance.memory.as_mut_ptr().add(value_offset as usize),
                    32
                );
            }
            
            let store_result = storage_store(&instance, key_offset as i32, value_offset as i32);
            assert!(store_result.is_ok());
            
            // Load the value back
            let result_offset = 64u32;
            let load_result = storage_load(&instance, key_offset as i32, result_offset as i32);
            assert!(load_result.is_ok());
            
            // Verify the loaded value matches
            let loaded_value = &instance.memory[result_offset as usize..(result_offset + 32) as usize];
            assert_eq!(loaded_value, value);
        }
    }
    
    #[test]
    fn test_storage_overwrite() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        let key = [0x44; 32];
        let value1 = [0xdd; 32];
        let value2 = [0xee; 32];
        
        let key_offset = 0u32;
        let value_offset = 32u32;
        let result_offset = 64u32;
        
        // Write key to memory
        unsafe {
            std::ptr::copy_nonoverlapping(
                key.as_ptr(),
                instance.memory.as_mut_ptr().add(key_offset as usize),
                32
            );
        }
        
        // Store first value
        unsafe {
            std::ptr::copy_nonoverlapping(
                value1.as_ptr(),
                instance.memory.as_mut_ptr().add(value_offset as usize),
                32
            );
        }
        let result = storage_store(&instance, key_offset as i32, value_offset as i32);
        assert!(result.is_ok());
        
        // Store second value (overwrite)
        unsafe {
            std::ptr::copy_nonoverlapping(
                value2.as_ptr(),
                instance.memory.as_mut_ptr().add(value_offset as usize),
                32
            );
        }
        let result = storage_store(&instance, key_offset as i32, value_offset as i32);
        assert!(result.is_ok());
        
        // Load and verify second value
        let result = storage_load(&instance, key_offset as i32, result_offset as i32);
        assert!(result.is_ok());
        
        let loaded_value = &instance.memory[result_offset as usize..(result_offset + 32) as usize];
        assert_eq!(loaded_value, &value2);
    }
}