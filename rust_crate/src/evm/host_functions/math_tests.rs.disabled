// Copyright (C) 2021-2025 the DTVM authors. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//! Unit tests for mathematical host functions

#[cfg(test)]
mod tests {
    use super::*;
    use crate::evm::MockContext;
    use crate::evm::host_functions::math::*;
    
    // Mock ZenInstance for testing
    struct MockZenInstance {
        context: MockContext,
        memory: Vec<u8>,
    }
    
    impl MockZenInstance {
        fn new(context: MockContext) -> Self {
            Self {
                context,
                memory: vec![0u8; 4096], // 4KB mock memory
            }
        }
        
        fn validate_wasm_addr(&self, offset: u32, length: u32) -> bool {
            (offset as usize + length as usize) <= self.memory.len()
        }
        
        unsafe fn get_host_memory(&self, offset: u32) -> *const u8 {
            self.memory.as_ptr().add(offset as usize)
        }
        
        fn write_to_memory(&mut self, offset: u32, data: &[u8]) {
            let start = offset as usize;
            let end = start + data.len();
            if end <= self.memory.len() {
                self.memory[start..end].copy_from_slice(data);
            }
        }
        
        fn read_from_memory(&self, offset: u32, length: u32) -> Vec<u8> {
            let start = offset as usize;
            let end = start + length as usize;
            if end <= self.memory.len() {
                self.memory[start..end].to_vec()
            } else {
                vec![]
            }
        }
    }
    
    impl AsRef<MockContext> for MockZenInstance {
        fn as_ref(&self) -> &MockContext {
            &self.context
        }
    }
    
    #[test]
    fn test_addmod_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data: (5 + 3) % 7 = 1
        let a = [0u8; 31].iter().chain([5u8].iter()).cloned().collect::<Vec<u8>>();
        let b = [0u8; 31].iter().chain([3u8].iter()).cloned().collect::<Vec<u8>>();
        let n = [0u8; 31].iter().chain([7u8].iter()).cloned().collect::<Vec<u8>>();
        
        let a_offset = 0u32;
        let b_offset = 32u32;
        let n_offset = 64u32;
        let result_offset = 96u32;
        
        // Write test data to memory
        instance.write_to_memory(a_offset, &a);
        instance.write_to_memory(b_offset, &b);
        instance.write_to_memory(n_offset, &n);
        
        // Call addmod
        let result = addmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        // Read the result
        let result_data = instance.read_from_memory(result_offset, 32);
        assert_eq!(result_data.len(), 32);
        
        // Verify it's a mock result (starts with 0x10)
        assert_eq!(result_data[0], 0x10);
        
        // Verify the operation type is encoded
        assert_eq!(result_data[1], 0x01); // addmod operation
    }
    
    #[test]
    fn test_mulmod_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data: (5 * 3) % 7 = 1
        let a = [0u8; 31].iter().chain([5u8].iter()).cloned().collect::<Vec<u8>>();
        let b = [0u8; 31].iter().chain([3u8].iter()).cloned().collect::<Vec<u8>>();
        let n = [0u8; 31].iter().chain([7u8].iter()).cloned().collect::<Vec<u8>>();
        
        let a_offset = 0u32;
        let b_offset = 32u32;
        let n_offset = 64u32;
        let result_offset = 96u32;
        
        // Write test data to memory
        instance.write_to_memory(a_offset, &a);
        instance.write_to_memory(b_offset, &b);
        instance.write_to_memory(n_offset, &n);
        
        // Call mulmod
        let result = mulmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        // Read the result
        let result_data = instance.read_from_memory(result_offset, 32);
        assert_eq!(result_data.len(), 32);
        
        // Verify it's a mock result (starts with 0x10)
        assert_eq!(result_data[0], 0x10);
        
        // Verify the operation type is encoded
        assert_eq!(result_data[1], 0x02); // mulmod operation
    }
    
    #[test]
    fn test_expmod_basic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data: (3 ^ 2) % 5 = 4
        let base = [0u8; 31].iter().chain([3u8].iter()).cloned().collect::<Vec<u8>>();
        let exp = [0u8; 31].iter().chain([2u8].iter()).cloned().collect::<Vec<u8>>();
        let modulus = [0u8; 31].iter().chain([5u8].iter()).cloned().collect::<Vec<u8>>();
        
        let base_offset = 0u32;
        let exp_offset = 32u32;
        let modulus_offset = 64u32;
        let result_offset = 96u32;
        
        // Write test data to memory
        instance.write_to_memory(base_offset, &base);
        instance.write_to_memory(exp_offset, &exp);
        instance.write_to_memory(modulus_offset, &modulus);
        
        // Call expmod
        let result = expmod(
            &instance,
            base_offset as i32,
            exp_offset as i32,
            modulus_offset as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        // Read the result
        let result_data = instance.read_from_memory(result_offset, 32);
        assert_eq!(result_data.len(), 32);
        
        // Verify it's a mock result (starts with 0x10)
        assert_eq!(result_data[0], 0x10);
        
        // Verify the operation type is encoded
        assert_eq!(result_data[1], 0x03); // expmod operation
    }
    
    #[test]
    fn test_math_invalid_offsets() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let instance = MockZenInstance::new(context);
        
        // Test negative offsets
        assert!(addmod(&instance, -1, 32, 64, 96).is_err());
        assert!(addmod(&instance, 0, -1, 64, 96).is_err());
        assert!(addmod(&instance, 0, 32, -1, 96).is_err());
        assert!(addmod(&instance, 0, 32, 64, -1).is_err());
        
        assert!(mulmod(&instance, -1, 32, 64, 96).is_err());
        assert!(expmod(&instance, -1, 32, 64, 96).is_err());
        
        // Test out-of-bounds offsets
        assert!(addmod(&instance, 4096, 32, 64, 96).is_err());
        assert!(mulmod(&instance, 0, 4096, 64, 96).is_err());
        assert!(expmod(&instance, 0, 32, 4096, 96).is_err());
    }
    
    #[test]
    fn test_math_zero_modulus() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Prepare test data with zero modulus
        let a = [0u8; 31].iter().chain([5u8].iter()).cloned().collect::<Vec<u8>>();
        let b = [0u8; 31].iter().chain([3u8].iter()).cloned().collect::<Vec<u8>>();
        let zero_n = [0u8; 32];
        
        let a_offset = 0u32;
        let b_offset = 32u32;
        let n_offset = 64u32;
        let result_offset = 96u32;
        
        // Write test data to memory
        instance.write_to_memory(a_offset, &a);
        instance.write_to_memory(b_offset, &b);
        instance.write_to_memory(n_offset, &zero_n);
        
        // Call addmod with zero modulus - should return zero
        let result = addmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        let result_data = instance.read_from_memory(result_offset, 32);
        // Should return zero for zero modulus
        assert_eq!(result_data, vec![0u8; 32]);
        
        // Same for mulmod
        let result = mulmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result_offset as i32,
        );
        assert!(result.is_ok());
        
        let result_data = instance.read_from_memory(result_offset, 32);
        assert_eq!(result_data, vec![0u8; 32]);
    }
    
    #[test]
    fn test_math_operations_different_results() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Same input data for all operations
        let a = [0u8; 31].iter().chain([10u8].iter()).cloned().collect::<Vec<u8>>();
        let b = [0u8; 31].iter().chain([7u8].iter()).cloned().collect::<Vec<u8>>();
        let n = [0u8; 31].iter().chain([13u8].iter()).cloned().collect::<Vec<u8>>();
        
        let a_offset = 0u32;
        let b_offset = 32u32;
        let n_offset = 64u32;
        let addmod_result_offset = 96u32;
        let mulmod_result_offset = 128u32;
        let expmod_result_offset = 160u32;
        
        // Write test data to memory
        instance.write_to_memory(a_offset, &a);
        instance.write_to_memory(b_offset, &b);
        instance.write_to_memory(n_offset, &n);
        
        // Call all three operations
        let addmod_result = addmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            addmod_result_offset as i32,
        );
        assert!(addmod_result.is_ok());
        
        let mulmod_result = mulmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            mulmod_result_offset as i32,
        );
        assert!(mulmod_result.is_ok());
        
        let expmod_result = expmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            expmod_result_offset as i32,
        );
        assert!(expmod_result.is_ok());
        
        // Read all results
        let addmod_data = instance.read_from_memory(addmod_result_offset, 32);
        let mulmod_data = instance.read_from_memory(mulmod_result_offset, 32);
        let expmod_data = instance.read_from_memory(expmod_result_offset, 32);
        
        // All should have the same prefix but different operation codes
        assert_eq!(addmod_data[0], 0x10);
        assert_eq!(mulmod_data[0], 0x10);
        assert_eq!(expmod_data[0], 0x10);
        
        // But different operation identifiers
        assert_eq!(addmod_data[1], 0x01);
        assert_eq!(mulmod_data[1], 0x02);
        assert_eq!(expmod_data[1], 0x03);
        
        // Results should be different
        assert_ne!(addmod_data, mulmod_data);
        assert_ne!(mulmod_data, expmod_data);
        assert_ne!(addmod_data, expmod_data);
    }
    
    #[test]
    fn test_math_deterministic() {
        let context = MockContext::new(vec![0x60, 0x80]);
        let mut instance = MockZenInstance::new(context);
        
        // Same input data
        let a = [0u8; 31].iter().chain([15u8].iter()).cloned().collect::<Vec<u8>>();
        let b = [0u8; 31].iter().chain([8u8].iter()).cloned().collect::<Vec<u8>>();
        let n = [0u8; 31].iter().chain([11u8].iter()).cloned().collect::<Vec<u8>>();
        
        let a_offset = 0u32;
        let b_offset = 32u32;
        let n_offset = 64u32;
        let result1_offset = 96u32;
        let result2_offset = 128u32;
        
        // Write test data to memory
        instance.write_to_memory(a_offset, &a);
        instance.write_to_memory(b_offset, &b);
        instance.write_to_memory(n_offset, &n);
        
        // Call addmod twice with same inputs
        let result1 = addmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result1_offset as i32,
        );
        assert!(result1.is_ok());
        
        let result2 = addmod(
            &instance,
            a_offset as i32,
            b_offset as i32,
            n_offset as i32,
            result2_offset as i32,
        );
        assert!(result2.is_ok());
        
        // Results should be identical (deterministic)
        let data1 = instance.read_from_memory(result1_offset, 32);
        let data2 = instance.read_from_memory(result2_offset, 32);
        assert_eq!(data1, data2);
    }
}